<?php
/**
 * This is the template for generating the model class of a specified table.
 * DO NOT EDIT THIS FILE! It may be regenerated with Gii.
 */

use yii\helpers\Inflector;
use yii\helpers\StringHelper;

/**
 * @var yii\web\View $this
 * @var string $tableName full table name
 * @var string $className class name
 * @var yii\db\TableSchema $tableSchema
 * @var string[] $labels list of attribute labels (name => label)
 * @var string[] $rules list of validation rules
 * @var string[] $searchModelRules list of validation rules for search Model
 * @var array $relations list of relations (name => relation declaration)
 *
 * @var $properties array list of properties (property => [type, name. comment])
 * @var $labels string[] list of attribute labels (name => label)
 * @var $rules string[] list of validation rules
 *
* @var $generator year\gii\goodmall\generators\repository\Generator
 */

$pkgPaths = [] ;

$pkgName = basename($generator->repositoryImplementPath);

// TODO  有包别名情况 需要重新构造下类型 比如 bu "github.com/beego/bee/utils"   此时需要用别名（localName） 替换掉末尾包名
$repoInterfaceType = $generator->repositoryInterfaceType ;

// 推入一个导入包
$pkgPaths[] = $generator->getPackagePath($repoInterfaceType) ;

$repoInterfaceType = $generator->resolveType($repoInterfaceType) ;
$repoImplementType = substr($repoInterfaceType,strrpos($repoInterfaceType,'.')+1) ;
$repoImplementType = lcfirst($repoImplementType) ;

$modelType = $generator->modelType ;
$searchModelType = $generator->searchModelType ;
// 推入 导入包
$pkgPaths[] = $generator->getPackagePath($modelType) ;
$pkgPaths[] = $generator->getPackagePath($searchModelType) ;

$modelType = $generator->resolveType($modelType) ;
$searchModelType = $generator->resolveType($searchModelType) ;

$searchConditions = $generator->generateSearchConditions() ;

?>
package <?= $pkgName ?>

import (
_ "encoding/json"
"errors"
"fmt"
"strconv"
"strings"
// "fmt"
// "log"
_ "math/rand"
// "path/filepath"
_ "strconv"

// "github.com/fatih/structs"
//"github.com/mitchellh/mapstructure"

_ "os"

// "github.com/goodmall/goodmall/base"
"github.com/goodmall/goodmall/pods/demo"

<?= implode("\n",array_unique($pkgPaths)) ?>

"github.com/jinzhu/copier"
"github.com/jinzhu/gorm"
_ "github.com/jinzhu/gorm/dialects/mysql"

. "github.com/go-xorm/builder"
. "github.com/goodmall/goodmall/base/xorm/builder"
)


// Ensure 接口被实现了.
var _ <?= $repoInterfaceType ?> = &<?= $repoImplementType  ?>{}

// gorm.xxx().xxx().Error 大部分的gorm方法  最后可以提取错误的
type <?= $repoImplementType  ?> struct {
    db *gorm.DB
}

func New<?= ucfirst($repoImplementType)  ?>(db *gorm.DB) <?=  $repoInterfaceType ?> {
/**
    // create table if needed
    db.AutoMigrate(&<?= $modelType ?>{})
*/
return &<?= $repoImplementType ?>{
        db: db,
    }
}

func (rp *<?= $repoImplementType ?>) Create(model *<?= $modelType ?>) error {

    err :=  rp.db.Create(model).Error
    if err != nil {
        return err
    }
    return nil

}

//
func (rp *<?= $repoImplementType ?>) Update(id int, model *<?= $modelType ?>) error {

    m := <?= $modelType ?>{}
    if result := rp.db.First(&m, id); result.Error != nil {
        return result.Error  // result.RecordNotFound
    }
    // 一定要确保没有查到时的检测 不然全表被修改 太危险啦！
    if m.Id == 0 {
        return errors.New("Not Found the model for id :" + strconv.Itoa(id))
    }

    model.Id = id
    if err := rp.db.Save(&model).Error ; err != nil {
        return err
    }
    return nil
}

func (rp *<?= $repoImplementType ?>) Remove(id int) error {

    //  FIXME 这里可能有问题  强哥的实现逻辑是 先用id查询一下 然后再删除
    return rp.db.Where("id = ?",id).Delete(<?= $modelType ?>{}).Error

}

// ## Query methods:

func (rp *<?= $repoImplementType?>) Load(id int) (*<?= $modelType ?>, error) {

    model := <?= $modelType ?>{}
    if err := rp.db.First(&model, id).Error ; err != nil {
        return nil , err
    }
    return &model, nil

}

// Query
func (rp *<?= $repoImplementType ?>) Query(sm <?= $searchModelType ?>, fields []string,  offset, limit int, sort string) ([]<?= $modelType ?>, error) {

    rslt := []<?= $modelType ?>{}

    // 构造条件子句
    sql, args := rp.buildSearchCond(sm)
    if len(strings.Trim(sort, " ")) == 0 {
        sort = "id desc"
    }

    // fmt.Println(sql, args)
    if len(sql) != 0 {
        rp.db.Where(sql, args...).
        Offset(offset).Limit(limit).
        Order(sort).
        Find(&rslt)
    } else {
        rp.db.Where(&sm).
        Offset(offset).Limit(limit).
        Order(sort).
        Find(&rslt)
    }

    return rslt, nil
}

func (rp *<?= $repoImplementType ?>) Count(sm <?= $searchModelType ?>) (int, error) {

    cnt := 0

    // 构造条件子句
    sql, args := rp.buildSearchCond(sm)

    if len(sql) != 0 {
         rp.db.Model(&<?= $modelType ?>{}).Where(sql, args...).Count(&cnt)
    } else {
         rp.db.Model(&<?= $modelType ?>{}).Count(&cnt)
    }

    return cnt, nil

}

func (rp *<?= $repoImplementType ?>) buildSearchCond(sm <?= $searchModelType?>) (sql string, args []interface{}) {

    conds := []Cond{
        <?=  implode("\t " , $searchConditions) ?>
    }

    // 构造条件子句
    sql, args, _ = ToSQL(
        And( conds...  ))

    return sql, args

}
